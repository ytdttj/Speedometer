package com.example.couplegps.networkimport android.content.Contextimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport com.example.couplegps.data.model.LocationDataimport com.google.gson.Gsonimport io.socket.client.IOimport io.socket.client.Socketimport org.json.JSONObjectimport android.util.Logimport java.net.URISyntaxException/** * Socket.IO客户端 * 用于与服务器通信，处理配对和位置共享 */class SocketClient(context: Context) {        // 配置Socket.IO服务器地址（应放入配置文件中）    private val SERVER_URL = "http://10.0.2.2:3000" // 本地开发用地址，指向电脑localhost        private var socket: Socket? = null    private val gson = Gson()        // 状态信息    private val _connectionStatus = MutableLiveData<ConnectionStatus>(ConnectionStatus.DISCONNECTED)    val connectionStatus: LiveData<ConnectionStatus> = _connectionStatus        // 配对状态    private val _pairingResult = MutableLiveData<PairingResult>()    val pairingResult: LiveData<PairingResult> = _pairingResult        // 接收到的配对码    private val _pairingCode = MutableLiveData<String>()    val pairingCode: LiveData<String> = _pairingCode        // 伴侣位置更新    private val _partnerLocation = MutableLiveData<LocationData>()    val partnerLocation: LiveData<LocationData> = _partnerLocation        // 配对变化事件    private val _pairingEvent = MutableLiveData<PairingEvent>()    val pairingEvent: LiveData<PairingEvent> = _pairingEvent        init {        try {            // 创建Socket.IO客户端实例            val options = IO.Options()            socket = IO.socket(SERVER_URL, options)                        setupSocketListeners()        } catch (e: URISyntaxException) {            Log.e(TAG, "Socket初始化错误", e)            _connectionStatus.value = ConnectionStatus.ERROR        }    }        /**     * 设置Socket.IO事件监听器     */    private fun setupSocketListeners() {        socket?.apply {            // 连接事件            on(Socket.EVENT_CONNECT) {                Log.d(TAG, "Socket已连接")                _connectionStatus.postValue(ConnectionStatus.CONNECTED)            }                        // 断开连接事件            on(Socket.EVENT_DISCONNECT) {                Log.d(TAG, "Socket已断开连接")                _connectionStatus.postValue(ConnectionStatus.DISCONNECTED)            }                        // 连接错误事件            on(Socket.EVENT_CONNECT_ERROR) {                Log.e(TAG, "Socket连接错误: $it")                _connectionStatus.postValue(ConnectionStatus.ERROR)            }                        // 接收配对码            on("pairing_code") { args ->                if (args.isNotEmpty() && args[0] is String) {                    val code = args[0] as String                    Log.d(TAG, "收到配对码: $code")                    _pairingCode.postValue(code)                }            }                        // 配对结果            on("pairing_result") { args ->                if (args.isNotEmpty() && args[0] is JSONObject) {                    val jsonResult = args[0] as JSONObject                    val result = PairingResult(                        success = jsonResult.optBoolean("success", false),                        message = jsonResult.optString("message", "未知错误"),                        pairId = jsonResult.optString("pairId", "")                    )                    Log.d(TAG, "配对结果: $result")                    _pairingResult.postValue(result)                                        if (result.success) {                        _pairingEvent.postValue(PairingEvent.PAIRED)                    }                }            }                        // 伴侣位置更新            on("partner_location") { args ->                if (args.isNotEmpty() && args[0] is JSONObject) {                    try {                        val jsonLocation = args[0] as JSONObject                        val locationJson = jsonLocation.toString()                        val locationData = gson.fromJson(locationJson, LocationData::class.java)                        Log.d(TAG, "收到伴侣位置: $locationData")                        _partnerLocation.postValue(locationData)                    } catch (e: Exception) {                        Log.e(TAG, "解析位置数据错误", e)                    }                }            }                        // 伴侣解除配对            on("partner_unpaired") {                Log.d(TAG, "伴侣解除了配对")                _pairingEvent.postValue(PairingEvent.PARTNER_UNPAIRED)            }                        // 伴侣断开连接            on("partner_disconnected") {                Log.d(TAG, "伴侣断开了连接")                _pairingEvent.postValue(PairingEvent.PARTNER_DISCONNECTED)            }                        // 解除配对成功            on("unpair_success") {                Log.d(TAG, "解除配对成功")                _pairingEvent.postValue(PairingEvent.UNPAIRED)            }        }    }        /**     * 连接到Socket.IO服务器     */    fun connect() {        if (_connectionStatus.value != ConnectionStatus.CONNECTED) {            Log.d(TAG, "正在连接到Socket服务器...")            socket?.connect()        }    }        /**     * 断开Socket.IO连接     */    fun disconnect() {        Log.d(TAG, "正在断开Socket连接...")        socket?.disconnect()    }        /**     * 请求生成配对码     */    fun requestPairingCode() {        if (_connectionStatus.value == ConnectionStatus.CONNECTED) {            Log.d(TAG, "请求生成配对码")            socket?.emit("generate_code")        } else {            Log.w(TAG, "Socket未连接，无法请求配对码")        }    }        /**     * 使用配对码进行配对     * @param code 6位数字配对码     */    fun pairWithCode(code: String) {        if (_connectionStatus.value == ConnectionStatus.CONNECTED) {            Log.d(TAG, "使用配对码配对: $code")            socket?.emit("pair_with_code", code)        } else {            Log.w(TAG, "Socket未连接，无法进行配对")            _pairingResult.postValue(PairingResult(false, "未连接到服务器", ""))        }    }        /**     * 发送位置更新     * @param locationData 位置数据     */    fun sendLocationUpdate(locationData: LocationData) {        if (_connectionStatus.value == ConnectionStatus.CONNECTED) {            try {                val locationJson = gson.toJson(locationData)                Log.d(TAG, "发送位置更新: $locationJson")                socket?.emit("location_update", JSONObject(locationJson))            } catch (e: Exception) {                Log.e(TAG, "发送位置更新失败", e)            }        }    }        /**     * 解除配对     */    fun unpair() {        if (_connectionStatus.value == ConnectionStatus.CONNECTED) {            Log.d(TAG, "请求解除配对")            socket?.emit("unpair")        }    }        companion object {        private const val TAG = "SocketClient"    }        /**     * 连接状态枚举     */    enum class ConnectionStatus {        CONNECTED, DISCONNECTED, ERROR    }        /**     * 配对结果数据类     */    data class PairingResult(        val success: Boolean,        val message: String,        val pairId: String    )        /**     * 配对事件枚举     */    enum class PairingEvent {        PAIRED, // 配对成功        UNPAIRED, // 解除配对成功        PARTNER_UNPAIRED, // 伴侣解除配对        PARTNER_DISCONNECTED // 伴侣断开连接    }}